{
  "name": "QBit - Microservices Lib",
  "tagline": "The Java microservice lib. QBit is a reactive programming lib for building microservices - JSON, HTTP, WebSocket, and REST. QBit uses reactive programming to build elastic REST, and WebSockets based cloud friendly, web services. SOA evolved for mobile and cloud.  ServiceDiscovery, Health, reactive StatService, events, Java idiomatic reactive programming for Microservices.",
  "body": "[QBit Micorservices tutorials](https://github.com/MammatusTech/qbit-microservices-examples/wiki) ..  | ..  [QBit uses Reakt](http://advantageous.github.io/reakt/) ..  | ..  [QBit works with Vert.x](http://vertx.io/) ..  | ..  [Reakt Vertx](http://advantageous.github.io/reakt-vertx/) .. | .. [Docs](https://github.com/advantageous/qbit/wiki)\r\n\r\n#QBit - The Microservice Lib for Java - JSON, REST, WebSocket, Speed! \r\n\r\n## Quick overview of QBit\r\n\r\nThe Java microservice lib. QBit is a reactive programming lib for building microservices - JSON, HTTP, WebSocket, and REST. QBit uses reactive programming to build elastic REST, and WebSockets based cloud friendly, web services. SOA evolved for mobile and cloud. ServiceDiscovery, Health, reactive StatService, events, Java idiomatic reactive programming for Microservices.\r\n\r\nGot a question? Ask here: [QBit Google Group](https://groups.google.com/forum/#!forum/qbit-microservice).\r\n\r\nEverything is a queue. You have a choice. You can embrace it and control it. You can optimize for it.\r\nOr you can hide behind abstractions. QBit opens you up to peeking into what is going on, and allows you\r\nto pull some levers without selling your soul.\r\n\r\nQBit is a library not a framework. You can mix and match QBit with Spring, Guice, etc.\r\n\r\n## New and Improved! \r\nQBit now supports [Reakt](http://advantageous.github.io/reakt/) invokable promises for local and remote client proxies. \r\nThis gives a nice fluent API for async programming. \r\n\r\n#### Invokeable promise\r\n```java\r\n        employeeService.lookupEmployee(\"123\")\r\n               .then((employee)-> {...}).catchError(...).invoke();\r\n```\r\n\r\nQBit callbacks are now also Reakt Callbacks without breaking the QBit contract for Callbacks. \r\n\r\nSee [Reakt Invokable Promises for more details](https://github.com/advantageous/reakt/wiki/Invokable-Promise).\r\n\r\n## QBit is FAST!\r\n\r\n![QBit the microservice framework for java](https://docs.google.com/spreadsheets/d/1kd3gjyyz1MyTJvNLJ-BC0YIkzIU-8YYLLrxpjUl0TBQ/pubchart?oid=781959089&format=image)\r\n\r\n## Getting started\r\n#### Using from maven\r\n\r\nQBit is published to the [maven public repo](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22io.advantageous.qbit%22%20). \r\n\r\n```xml\r\n<dependency>\r\n    <groupId>io.advantageous.qbit</groupId>\r\n    <artifactId>qbit-admin</artifactId>\r\n    <version>1.5.0.RELEASE</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>io.advantageous.qbit</groupId>\r\n    <artifactId>qbit-vertx</artifactId>\r\n    <version>1.5.0.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n#### Using from gradle\r\n```java\r\ncompile 'io.advantageous.qbit:qbit-admin:1.5.0.RELEASE'\r\ncompile 'io.advantageous.qbit:qbit-vertx:1.5.0.RELEASE'\r\n```\r\n\r\nCore Features\r\n============\r\n\r\n* Write REST based async microservices\r\n* Write ***WebSocket*** based async microservices (fast async RPC over WebSocket)\r\n* Actor Service Queues using micro-batching for high-speed message passing\r\n* Strongly async typed event bus which can be distributed\r\n* Async low overhead metrics gathering which can be queried and distributed (for doing fast lane analytics)\r\n* Complex async call coordination (with the Reactor) for reactive programming\r\n* Built-in support for ***health checks*** (and integration with tools like Consul)\r\n* Built-in support for ***monitoring*** (and integration with wire protocols like StatsD)\r\n* Built-in support for ***Service Discovery*** (with integration with health system, DNS SRV records and Consul)\r\n* Integration with persistent queues\r\n* [12 factor app port bindings](http://12factor.net/), health checks, KPI gathering, Logging MDC\r\n* API Gateway support for client generation and consumption via [Swagger](http://swagger.io/).\r\n* Our services can generate Swagger files (like idl for JSON/REST).\r\n* Remote client proxies for WebSocket (your interface is your IDL)\r\n\r\n\r\nStatus\r\n=====\r\nDeployed at several large fortune 100 companies. \r\nQBit now works with Vertx (standalone or embedded).\r\nYou can also use QBit on non-QBit projects, it is just a lib.\r\n\r\nLicense\r\n=====\r\nApache 2\r\n\r\n\r\n## Java Microservice Lib\r\n\r\nQBit has inproc services, REST microservices and WebSocket microservices as well as an\r\nin-proc service event bus (which can be per module or per app). It supports workers and in-memory services.\r\n\r\nBefore we describe more, here are two sample services:\r\n\r\n#### Todo Service\r\n```java\r\n\r\n@RequestMapping(\"/todo-service\")\r\npublic class TodoService {\r\n\r\n    @RequestMapping(\"/todo/count\")\r\n    public int size() {...\r\n\r\n    @RequestMapping(\"/todo/\")\r\n    public List<TodoItem> list() {...\r\n```\r\n\r\n\r\n#### Adder Service using URI params\r\n```java\r\n\r\n    @RequestMapping(\"/adder-service\")\r\n    public class AdderService {\r\n\r\n        @RequestMapping(\"/add/{0}/{1}\")\r\n        public int add(@PathVariable int a, @PathVariable int b) {...\r\n    }\r\n```\r\n\r\n\r\n\r\nQBit philosophy:\r\n====\r\nAt the end of the day QBit is a simple library not a framework.\r\nYour app is not a QBit app but a Java app that uses the QBit lib.\r\nQBit allows you to work with Java UTIL concurrent, and does not endeavor to hide it from you.\r\nJust trying to take the sting out of it.\r\n\r\nDoes it work\r\n=====\r\nWe have used techniques in Boon and QBit with great success in high-end, high-performance, high-scalable apps.\r\nWe helped clients handle 10x the load with 1/10th the servers of their competitors using techniques in QBit.\r\nQBit is us being sick of hand tuning queue access and threads.\r\n\r\n\r\nBoon and QBit humility policy\r\n=====\r\nIdeas for Boon and QBit often come from all over the web. We make mistakes. Point them out.\r\nAs a developer of Boon and QBit, we are fellow travelers.\r\nIf you have an idea or technique you want to share, we listen.\r\n\r\n\r\nInspiration\r\n====\r\n\r\nA big inspiration for Boon/QBit was Vertx, Akka, Go Channels, Active Objects, Apartment Model Threading, Actor,\r\nand the Mechanical Sympathy papers.\r\n\r\nQBit has ideas that are similar to many frameworks. We are all reading the same papers.\r\nQBit got inspiration from the LMAX disruptor papers and this blog post about\r\n[link transfer queue versus disruptor](http://php.sabscape.com/blog/?p=557). We had some theories about\r\nqueues that blog post inspired us to try them out. Some of these theories are deployed at some of the\r\nbiggest middleware backends and whose name brands are known around the world. And thus QBit was born.\r\n\r\nQBit also took an lot of inspiration by the great work done\r\nby Tim Fox on Vertx. The first project using something that could actually be called QBit (albeit early QBit)\r\n was using Vertx on an web/mobile microservice for an app that could potentially have 80 million users.\r\n It was this\r\nexperience with Vertx and early QBit that led to QBit development and evolution. QBit is built on the\r\nshoulders of giants (Netty/Vertx).\r\n\r\nDoes QBit compete with...\r\n====\r\nSpring Disruptor: No. You could use QBit to write plugins for Spring Disruptor I suppose, but QBit does\r\nnot compete with Spring Disruptor.\r\nSpring Boot/Spring MVC: No. We use the same annotations but QBit is geared for high-speed in-memory\r\nmicroservices. It is more like Akka than Spring Boot. QBit has a subset of the features of Spring MVC\r\ngeared only for microservices, i.e., WebSocket RPC, REST, JSON marshaling, etc.\r\nAkka: No. Well Maybe. Akka has similar concepts but they take a different approach. QBit is more focused\r\n on Java, and microservices (REST, JSON, WebSocket) than Akka.\r\nLMAX Disruptor: No. In fact, we can use disruptor as on of the queues that QBit uses underneath the covers.\r\n\r\n\r\n(Early benchmarks have been removed. They were here. QBit got a lot faster.\r\n Benchmarking QBit is a moving target at the moment.\r\n Links and reports will be created.)\r\n\r\n\r\nCode Examples\r\n\r\n\r\n## Basic Queue example (REST style services is further down)\r\n\r\n====\r\n\r\n```java\r\n\r\n     BasicQueue<Integer> queue =  BasicQueue.create(Integer.class, 1000);\r\n\r\n    //Sending threads\r\n\r\n     SendQueue<Integer> sendQueue = queue.sendQueue();\r\n     for (int index = 0; index < amount; index++) {\r\n           sendQueue.send(index);\r\n     }\r\n     sendQueue.flushSends();\r\n     ...\r\n     sendQueue.sendAndFlush(code);\r\n     //other methods for sendQueue, writeBatch, writeMany\r\n\r\n\r\n     //Receiving Threads\r\n     ReceiveQueue<Integer> receiveQueue = queue.receiveQueue();\r\n     Integer item = receiveQueue.take();\r\n     //other methods poll(), pollWait(), readBatch(), readBatch(count)\r\n```\r\n\r\n\r\n### What is QBit again?\r\n\r\nQBit is a queuing library for microservices. It is similar to many other projects like Akka, Spring Reactor,\r\netc. QBit is just a library not a platform. QBit has libraries to put a service behind a queue.\r\nYou can use QBit queues directly or you can create a service. QBit services can be exposed by WebSocket,\r\nHTTP, HTTP pipeline, and other types of remoting. A service in QBit is a Java class whose methods are\r\n executed behind service queues. QBit implements apartment model threading and is similar to the\r\n Actor model or a better description would be Active Objects. QBit does not use a disruptor (but could).\r\n It uses regular Java Queues. QBit can do north of 100 million ping pong calls per second which is\r\n  an amazing speed (seen as high as 200M). QBit also supports calling services via REST, and WebSocket.\r\n   QBit is microservices in the pure Web sense: JSON, HTTP, WebSocket, etc. QBit uses micro batching to\r\n    push messages through the pipe (queue, IO, etc.) faster to reduce thread hand-off.\r\n\r\n### QBit lingo\r\n\r\nQBit is a Java microservice lib supporting REST, JSON and WebSocket. It is written in Java but we could\r\none day write a version in Rust or Go or C# (but that would require a large payday).\r\n\r\n**Service**\r\nPOJO (plain old Java object) behind a queue that can receive method calls via proxy calls or events\r\n(May have one thread managing events, method calls, and responses or two one for method calls and events\r\n and the other for responses so response handlers do not block service. One is faster unless responses block). Services can use Spring MVC style REST annotations to expose themselves to the outside world via REST and WebSocket.\r\n\r\n**ServiceBundle**\r\nMany POJOs behind one response queue and many receive queues. There may be one thread for all responses\r\nor not. They also can be one receive queue.\r\n\r\n**Queue**\r\nA thread managing a queue. It supports batching. It has events for empty, reachedLimit, startedBatch,\r\nidle. You can listen to these events from services that sit behind a queue. You don't have to use Services.\r\nYou can use Queue's direct. In QBit, you have sender queues and receivers queues. They are separated to\r\nsupport micro-batching.\r\n\r\n**ServiceEndpointServer**\r\nServiceBundle that is exposed to REST and WebSocket communication.\r\n\r\n**EventBus**\r\nEventBus is a way to send a lot of messages to services that may be loosely coupled.\r\n\r\n**ClientProxy**\r\nClientProxy is a way to invoke service through async interface, service can be inproc (same process) or\r\nremoted over WebSocket.\r\n\r\n**Non-blocking**\r\nQBit is a non-blocking lib. You use CallBacks via Java 8 Lambdas. You can also send event messages and get\r\nreplies. Messaging is built into the system so you can easily coordinate complex tasks.\r\nQBit takes an object-oriented approach to service development so services look like normal Java services\r\nthat you\r\nalready write, but the services live behind a queue/thread. This is not a new concept. Microsoft did this\r\nwith DCOM/COM and called it active objects. Akka does it with actors and called them strongly typed Actors.\r\nThe important concepts is that you get the speed of reactive and actor style messaging but you develop\r\nin a natural OOP approach. QBit is not the first. QBit is not the only.\r\n\r\n\r\n**Speed**\r\nQBit is VERY fast. There is a of course a lot of room for improvement. But already 200M+ TPS inproc ping pong, 10M-20M+ TPS event bus, 500K TPS RPC calls over WebSocket/JSON, etc.\r\nMore work needs to be done to improve speed, but now it is fast enough where we are focusing more on\r\nusability.\r\nThe JSON support uses Boon by default which is up to 4x faster than other JSON parsers for the\r\nREST/JSON, WebSocket/JSON use case.\r\n\r\n**Reactive Programming**\r\nQBit provides a **Reactor** to manage async calls. This allows callbacks to be handled on the same thread that called them and it provides for timeout and error handling. Read [Reactor tutorial for creating reactive micro service programming](https://github.com/MammatusTech/qbit-microservices-examples/wiki/Reactor-tutorial--%7C-reactively-handling-async-calls-with-QBit-Reactive-Microservices)\r\n\r\n**Service Discovery**\r\nBuilt in support for service discovery. This includes integration with Consul.\r\n\r\n\r\n**StatService**\r\nBuilt in support for stats. The **StatService** can be integrated with **StatsD** (Graphite, Grafana, DataDog, etc.) to publish passive stats. Or you can query the stats engine and react to the stats (counts, timings and levels). The **StatsService** is a reactive stats system that can be clustered. The StatService is reactive in that your services can publish to it and query it and react based on the results. You can implement things like rate limiting and react to an increased rate of something. The ServiceDiscovery system integrates with the HealthSystem and Consul to roll up each of your internal services that make up you micro service and publish the composite availably of your micro service to a single HTTP endpoint or a dead mans switch in Consul (TTL). \r\n\r\n\r\n\r\n### CURLable REST services example\r\n\r\nTalk is cheap. Let's look at some code. You can get a detailed walk through in the Wiki.\r\nWe have a lot of documentation already.\r\n\r\nWe will create a service that is exposed through REST/JSON.\r\n\r\nTo query the size of the todo list:\r\n\r\n```bash\r\ncurl localhost:8080/services/todo-service/todo/count\r\n```\r\n\r\nTo add a new TODO item.\r\n\r\n```bash\r\ncurl -X POST -H \"Content-Type: application/json\" -d \\\r\n'{\"name\":\"xyz\",\"description\":\"xyz\"}' \\\r\nhttp://localhost:8080/services/todo-service/todo\r\n```\r\n\r\nTo get a list of TODO items\r\n```bash\r\ncurl http://localhost:8080/services/todo-service/todo/\r\n```\r\n\r\nThe TODO example will use and track Todo items.\r\n\r\n#### Todo item POJO sans getter\r\n\r\n```java\r\npackage io.advantageous.qbit.examples;\r\n\r\nimport java.util.Date;\r\n\r\n\r\npublic class TodoItem {\r\n\r\n\r\n    private final String description;\r\n    private final String name;\r\n    private final Date due;\r\n\r\n```\r\n\r\nThe TodoService uses Spring MVC style annotations.\r\n\r\n#### Todo Service\r\n```java\r\n\r\n@RequestMapping(\"/todo-service\")\r\npublic class TodoService {\r\n\r\n\r\n    private List<TodoItem> todoItemList = new ArrayList<>();\r\n\r\n\r\n    @RequestMapping(\"/todo/count\")\r\n    public int size() {\r\n\r\n        return todoItemList.size();\r\n    }\r\n\r\n    @RequestMapping(\"/todo/\")\r\n    public List<TodoItem> list() {\r\n\r\n        return todoItemList;\r\n    }\r\n\r\n    @RequestMapping(value = \"/todo\", method = RequestMethod.POST)\r\n    public void add(TodoItem item) {\r\n\r\n        todoItemList.add(item);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n#### Sending non-JSON\r\n\r\nYou can POST/PUT non-JSON and you can capture the body as a `String` or as a `byte[]`. \r\nIf the content-type is set to anything but `application/json` and your body is defined a String or byte[].\r\nThis works automatically. (The content-type has to be set.)\r\n\r\n```java\r\n    @RequestMapping(value = \"/body/bytes\", method = RequestMethod.POST)\r\n    public boolean bodyPostBytes( byte[] body) {\r\n        String string = new String(body, StandardCharsets.UTF_8);\r\n        return string.equals(\"foo\");\r\n    }\r\n\r\n    @RequestMapping(value = \"/body/string\", method = RequestMethod.POST)\r\n    public boolean bodyPostString(String body) {\r\n        return body.equals(\"foo\");\r\n    }\r\n```\r\n\r\n\r\n#### Sending different response codes for success\r\n\r\nBy default QBit sends a `200` (OK) for a non-void call (a call that has a return or a Callback). If the REST operation has no return or no callback then QBit sends a `202` (Accepted). There may be times when you want to send a 201 (Created) or some other code that is not an Exception. You can do that by setting `code` on `@RequestMapping`. By default the code is -1 which means use the default behavior (200 for success, 202 for one-way message, and 500 for errors).\r\n\r\n\r\n#### Sending different response codes for success\r\n```java\r\n\r\n  @RequestMapping(value = \"/helloj7\", code = 221)\r\n    public void helloJSend7(Callback<JSendResponse<List<String>>> callback) {\r\n        callback.returnThis(JSendResponseBuilder.jSendResponseBuilder(Lists.list(\r\n                \"hello \" + System.currentTimeMillis())).build());\r\n    }\r\n\r\n```\r\n\r\n`Callbacks` can be used for internal services as well. It is often the case that you use a [CallbackBuilder](https://github.com/advantageous/qbit/wiki/%5BDocument%5D-CallbackBuilder-and-generics-for-Reactive-Java-Microservices) or a QBit [Reactor](https://github.com/MammatusTech/qbit-microservices-examples/wiki/Reactor-tutorial--%7C-reactively-handling-async-calls-with-QBit-Reactive-Microservices) to manage service calls. \r\n\r\n#### Working with non JSON responses\r\n\r\nYou do not have to return JSON form rest calls.\r\nYou can return any binary or any text by using `HttpBinaryResponse` and `HttpTextResponse`.\r\n\r\n#### Returning non JSON from REST call\r\n```java\r\n      @RequestMapping(method = RequestMethod.GET)\r\n        public void ping2(Callback<HttpTextResponse> callback) {\r\n\r\n            callback.returnThis(HttpResponseBuilder.httpResponseBuilder()\r\n                    .setBody(\"hello mom\").setContentType(\"mom\")\r\n                    .setCode(777)\r\n                    .buildTextResponse());\r\n        }\r\n```\r\n\r\n\r\n#### Returning binary from REST call\r\n```java\r\n      @RequestMapping(method = RequestMethod.GET)\r\n        public void ping2(Callback<HttpBinaryResponse> callback) {\r\n\r\n            callback.returnThis(HttpResponseBuilder.httpResponseBuilder()\r\n                    .setBody(\"hello mom\").setContentType(\"mom\")\r\n                    .setCode(777)\r\n                    .buildBinaryResponse());\r\n        }\r\n```\r\n\r\n#### Side note Why Spring style annotations?\r\nWhy did we pick Spring style annotations?\r\n1) Spring is not a standard and neither is QBit. 2) We found the Spring annotations to be less verbose.\r\n3) More people use Spring than Java EE. We wrote QBit for people to use.\r\nWe could easily support JAX-RS style annotations, and we probably will.\r\nSince QBit focuses on JSON, we do not need all of the complexity of JAX-RS or even all the features of\r\nthe Spring MVC annotations. Also we can literally use the actual Spring annotations. QBit and Boon\r\nuse a non-type safe mechanism for annotations which means they are not tied to a particular lib.\r\nYou can define your own. We hate vendor tie-in even if it is an open source vendor.\r\n(We also support @POST, @GET which is similar to JAX-RS).\r\n\r\nNow just start it up.\r\n\r\n```java\r\n\r\n    public static void main(String... args) {\r\n\r\n        ServiceEndpointServer server = new EndpointServerBuilder().build();\r\n        server.initServices(new TodoService());\r\n        server.start();\r\n    }\r\n```\r\n\r\n\r\n\r\nThat is it. There is also out of the box WebSocket support with client side proxy generation so\r\nyou can call into services at the rate of millions of calls per second.\r\n\r\n## Using URI Params for QBit microservice\r\n\r\n```java\r\n\r\n    @RequestMapping(\"/adder-service\")\r\n    public class AdderService {\r\n\r\n\r\n        @RequestMapping(\"/add/{0}/{1}\")\r\n        public int add(@PathVariable int a, @PathVariable int b) {\r\n\r\n            return a + b;\r\n        }\r\n    }\r\n\r\n```\r\n\r\n## WebSocket\r\nYou can always invoke QBit services via a WebSocket proxy.\r\nThe advantage of a WebSocket proxy is it allows you execute 1M RPC+ a second (1 million remote calls\r\nevery second).\r\n\r\n\r\n#### Using a microservice remotely with WebSocket\r\n```java\r\n       /* Start QBit client for WebSocket calls. */\r\n        final Client client = clientBuilder()\r\n                   .setPort(7000).setRequestBatchSize(1).build();\r\n\r\n\r\n       /* Create a proxy to the service. */\r\n        final AdderServiceClientInterface adderService =\r\n                client.createProxy(AdderServiceClientInterface.class,\r\n                \"adder-service\");\r\n\r\n        client.start();\r\n\r\n\r\n\r\n       /* Call the service */\r\n        adderService.add(System.out::println, 1, 2);\r\n\r\n```\r\n\r\nThe output is 3.\r\n\r\n```output\r\n3\r\n```\r\n\r\n\r\nThe above uses a WebSocket proxy interface to call the service async.\r\n\r\n```java\r\n\r\n    interface AdderServiceClientInterface {\r\n\r\n        void add(Callback<Integer> callback, int a, int b);\r\n    }\r\n```\r\n\r\n#### ServiceDiscovery aware websocket builders\r\n\r\nCreate websocket service client that is ServiceDiscovery aware.\r\n\r\n\r\n```java\r\n        final Client client = clientBuilder.setServiceDiscovery(serviceDiscovery, \"echo\")\r\n                .setUri(\"/echo\").setProtocolBatchSize(20).build().startClient();\r\n\r\n\r\n        final EchoAsync echoClient = client.createProxy(EchoAsync.class, \"echo\");\r\n```\r\n\r\nCurrently the `clientBuilder` will load all service endpoints that are registered under the service name,\r\nand randomly pick one. \r\n\r\nServiceDiscovery includes Consul based, watching JSON files on disk, and DNS. It is easy to write your own service discovery as well and plug it into QBit.\r\n\r\n\r\nIn the future we can RoundRobin calls or shard calls to websocket service and/or provide auto fail over if the connection is closed. We do this for the event bus that uses service discovery but it is not baked into WebSocket based client stubs yet.\r\n\r\n\r\n## REST call with URI params\r\n\r\nThe last client example uses WebSocket. You could also just use REST, and actually use the URI params\r\nthat we setup.\r\nREST is nice but it is going to be slower than WebSocket support.\r\n\r\nQBit ships with a nice little HTTP client. We can use it.\r\n\r\nYou can use it to send async calls and WebSocket messages with the HTTP client.\r\n\r\n\r\nHere we will use the http client to invoke our remote method:\r\n\r\n#### Using a microservice remotely with REST QBit microservice client\r\n```java\r\n\r\n\r\n        HttpClient httpClient = httpClientBuilder()\r\n                .setHost(\"localhost\")\r\n                .setPort(7000).build();\r\n\r\n        httpClient.start();\r\n        String results = httpClient\r\n                   .get(\"/services/adder-service/add/2/2\").body();\r\n        System.out.println(results);\r\n\r\n```\r\n\r\n\r\nThe output is 4.\r\n\r\n```output\r\n4\r\n```\r\n\r\n## Accessing The URI Param example with CURL\r\n\r\nYou can also access the service from curl.\r\n\r\n```bash\r\n$ curl http://localhost:7000/services/adder-service/add/2/2\r\n```\r\n\r\nSee this full example here: [QBit microservice getting started tutorial](https://github.com/advantageous/qbit/wiki/%5BDetailed-Tutorial%5D-------------QBit-microservice-example).\r\n\r\n[QBit URI params and WebSocket proxy client](https://github.com/advantageous/qbit/wiki/%5BRough-Cut%5D-Using-QBit-microservice-lib's-REST-support-with-URI-Params)\r\n\r\n## Working with WebSocket, HttpClient etc.\r\n\r\nQBit has a library for working with and writing async microservices that is lightweight and fun to use.\r\n\r\n#### WebSocket server and client.\r\n\r\n\r\n#### Create an HTTP server\r\n```java\r\n\r\n        /* Create an HTTP server. */\r\n        HttpServer httpServer = httpServerBuilder()\r\n                .setPort(8080).build();\r\n\r\n```\r\n\r\n#### Setup server WebSocket support\r\n```java\r\n        /* Setup WebSocket Server support. */\r\n        httpServer.setWebSocketOnOpenConsumer(webSocket -> {\r\n            webSocket.setTextMessageConsumer(message -> {\r\n                webSocket.sendText(\"ECHO \" + message);\r\n            });\r\n        });\r\n\r\n```\r\n\r\n#### Start the server\r\n```java\r\n\r\n        /* Start the server. */\r\n        httpServer.start();\r\n```\r\n\r\n#### Setup the WebSocket client\r\n```java\r\n\r\n        /** CLIENT. */\r\n\r\n        /* Setup an httpClient. */\r\n        HttpClient httpClient = httpClientBuilder()\r\n                .setHost(\"localhost\").setPort(8080).build();\r\n        httpClient.start();\r\n```\r\n\r\n#### Client WebSocket\r\n\r\n```java\r\n\r\n        /* Setup the client websocket. */\r\n        WebSocket webSocket = httpClient\r\n                .createWebSocket(\"/websocket/rocket\");\r\n\r\n        /* Setup the text consumer. */\r\n        webSocket.setTextMessageConsumer(message -> {\r\n            System.out.println(message);\r\n        });\r\n        webSocket.openAndWait();\r\n\r\n        /* Send some messages. */\r\n        webSocket.sendText(\"Hi mom\");\r\n        webSocket.sendText(\"Hello World!\");\r\n\r\n```\r\n\r\n#### Output\r\n```output\r\n\r\nECHO Hi mom\r\nECHO Hello World!\r\n\r\n```\r\n\r\nNow stop the server and client. Pretty easy eh?\r\n\r\n## High-speed HTTP client and server done microservice style\r\n\r\n\r\n##### Starting up an HTTP server\r\n\r\n```java\r\n\r\n        /* Create an HTTP server. */\r\n        HttpServer httpServer = httpServerBuilder()\r\n                .setPort(8080).build();\r\n\r\n        /* Setting up a request Consumer with Java 8 Lambda expression. */\r\n        httpServer.setHttpRequestConsumer(httpRequest -> {\r\n\r\n            Map<String, Object> results = new HashMap<>();\r\n            results.put(\"method\", httpRequest.getMethod());\r\n            results.put(\"uri\", httpRequest.getUri());\r\n            results.put(\"body\", httpRequest.getBodyAsString());\r\n            results.put(\"headers\", httpRequest.getHeaders());\r\n            results.put(\"params\", httpRequest.getParams());\r\n            httpRequest.getReceiver()\r\n                .response(200, \"application/json\", Boon.toJson(results));\r\n        });\r\n\r\n\r\n        /* Start the server. */\r\n        httpServer.start();\r\n\r\n\r\n```\r\n\r\nThe focus is on ease of use and using Java 8 Lambdas for callbacks so the code is tight and small.\r\n\r\n[Find out more about QBit's microservice style WebSocket support here](https://github.com/advantageous/qbit/wiki/%5BDoc%5D-Using-QBit-microservice-lib's-WebSocket-support)\r\n\r\n\r\n## Using HTTP Client lib\r\n\r\nNow, let's try out our HTTP client.\r\n\r\n##### Starting up an HTTP client\r\n\r\n```java\r\n\r\n        /* Setup an httpClient. */\r\n        HttpClient httpClient = httpClientBuilder()\r\n                  .setHost(\"localhost\").setPort(8080).build();\r\n        httpClient.start();\r\n```\r\n\r\nYou just pass the URL, the port and then call start.\r\n\r\n## Synchronous HTTP calls\r\n\r\nNow you can start sending HTTP requests.\r\n\r\n##### No Param HTTP GET\r\n\r\n```java\r\n        /* Send no param get. */\r\n        HttpResponse httpResponse = httpClient.get( \"/hello/mom\" );\r\n        puts( httpResponse );\r\n```\r\n\r\nAn HTTP response just contains the results from the server.\r\n\r\n\r\n##### No Param HTTP Response\r\n\r\n```java\r\npublic interface HttpResponse {\r\n\r\n    MultiMap<String, String> headers();\r\n\r\n    int code();\r\n\r\n    String contentType();\r\n\r\n    String body();\r\n\r\n}\r\n\r\n```\r\n\r\nThere are helper methods for sync HTTP GET calls.\r\n\r\n\r\n\r\n##### Helper methods for GET\r\n```java\r\n\r\n\r\n        /* Send one param get. */\r\n        httpResponse = httpClient.getWith1Param(\"/hello/singleParam\",\r\n                                        \"hi\", \"mom\");\r\n        puts(\"single param\", httpResponse );\r\n\r\n\r\n        /* Send two param get. */\r\n        httpResponse = httpClient.getWith2Params(\"/hello/twoParams\",\r\n                \"hi\", \"mom\", \"hello\", \"dad\");\r\n        puts(\"two params\", httpResponse );\r\n\r\n...\r\n\r\n        /* Send five param get. */\r\n        httpResponse = httpClient.getWith5Params(\"/hello/5params\",\r\n                \"hi\", \"mom\",\r\n                \"hello\", \"dad\",\r\n                \"greetings\", \"kids\",\r\n                \"yo\", \"pets\",\r\n                \"hola\", \"neighbors\");\r\n        puts(\"5 params\", httpResponse );\r\n\r\n\r\n```\r\n\r\nThe puts method is a helper method it does System.out.println more or less by the way.\r\n\r\nThe first five params are covered. Beyond five, you have to use the HttpBuilder.\r\n\r\n```java\r\n\r\n\r\n        /* Send six params with get. */\r\n\r\n        final HttpRequest httpRequest = httpRequestBuilder()\r\n                .addParam(\"hi\", \"mom\")\r\n                .addParam(\"hello\", \"dad\")\r\n                .addParam(\"greetings\", \"kids\")\r\n                .addParam(\"yo\", \"pets\")\r\n                .addParam(\"hola\", \"pets\")\r\n                .addParam(\"salutations\", \"all\").build();\r\n\r\n        httpResponse = httpClient.sendRequestAndWait(httpRequest);\r\n        puts(\"6 params\", httpResponse );\r\n```\r\n\r\n## Http Async HTTP Client\r\n\r\nThere are async calls for GET as well.\r\n\r\n#### Async calls for HTTP GET using Java 8 lambda\r\n\r\n```java\r\n\r\n        /* Using Async support with lambda. */\r\n        httpClient.getAsync(\"/hi/async\", (code, contentType, body) -> {\r\n            puts(\"Async text with lambda\", body);\r\n        });\r\n\r\n        Sys.sleep(100);\r\n\r\n\r\n        /* Using Async support with lambda. */\r\n        httpClient.getAsyncWith1Param(\"/hi/async\", \"hi\", \"mom\", (code, contentType, body) -> {\r\n            puts(\"Async text with lambda 1 param\\n\", body);\r\n        });\r\n\r\n        Sys.sleep(100);\r\n\r\n\r\n\r\n        /* Using Async support with lambda. */\r\n        httpClient.getAsyncWith2Params(\"/hi/async\",\r\n                \"p1\", \"v1\",\r\n                \"p2\", \"v2\",\r\n                (code, contentType, body) -> {\r\n                    puts(\"Async text with lambda 2 params\\n\", body);\r\n                });\r\n\r\n        Sys.sleep(100);\r\n\r\n\r\n...\r\n        /* Using Async support with lambda. */\r\n        httpClient.getAsyncWith5Params(\"/hi/async\",\r\n                \"p1\", \"v1\",\r\n                \"p2\", \"v2\",\r\n                \"p3\", \"v3\",\r\n                \"p4\", \"v4\",\r\n                \"p5\", \"v5\",\r\n                (code, contentType, body) -> {\r\n                    puts(\"Async text with lambda 5 params\\n\", body);\r\n                });\r\n\r\n        Sys.sleep(100);\r\n\r\n```\r\n\r\n[Find more about the easy to use, fast microservice HTTP client here]\r\n(https://github.com/advantageous/qbit/wiki/%5BDoc%5D-Using-QBit-microservice-lib's-HttpClient-GET,-POST,-et-al,-JSON,-Java-8-Lambda).\r\n\r\n## InProc QBit services\r\n\r\nQBit allows for services behind queues to be run in-proc as well.\r\n\r\n```java\r\n\r\n        /* POJO service. */\r\n        final TodoManager todoManagerImpl = new TodoManager();\r\n\r\n        /*\r\n        Create the service which manages async calls to todoManagerImpl.\r\n         */\r\n        final Service service = serviceBuilder()\r\n                .setServiceObject(todoManagerImpl)\r\n                .build().startServiceQueue();\r\n\r\n\r\n        /* Create Asynchronous proxy over Synchronous service. */\r\n        final TodoManagerClientInterface todoManager =\r\n              service.createProxy(TodoManagerClientInterface.class);\r\n\r\n        service.startCallBackHandler();\r\n\r\n\r\n        System.out.println(\"This is an async call\");\r\n        /* Asynchronous method call. */\r\n        todoManager.add(new Todo(\"Call Mom\", \"Give Mom a call\"));\r\n\r\n\r\n        AtomicInteger countTracker = new AtomicInteger();\r\n        //Hold count from async call to service... for testing and showing it is an async callback\r\n\r\n        System.out.println(\"This is an async call to count\");\r\n\r\n        todoManager.count(count -> {\r\n            System.out.println(\"This lambda expression is the callback \" + count);\r\n\r\n            countTracker.set(count);\r\n        });\r\n\r\n\r\n        todoManager.clientProxyFlush(); //Flush all methods. It batches calls.\r\n\r\n        Sys.sleep(100);\r\n\r\n        System.out.printf(\"This is the count back from the server %d\\n\", countTracker.get());\r\n\r\n```\r\n\r\n[Detailed tutorial on in-proc services is being written.](https://github.com/advantageous/qbit/wiki/%5BDetailed-Tutorial%5D-Working-with-inproc-MicroServices-within-QBit.)\r\n\r\n\r\n## QBit Event Bus\r\n\r\n[QBit Event Bus more detailed example](https://github.com/advantageous/qbit/wiki/%5BRough-Cut%5D-Working-with-event-bus-for-QBit-the-microservice-engine)\r\n\r\nQBit also has a service event bus. This example is a an employee benefits services example.\r\n\r\nWe have two channels.\r\n\r\n```\r\npublic static final String NEW_HIRE_CHANNEL = \"com.mycompnay.employee.new\";\r\n\r\npublic static final String PAYROLL_ADJUSTMENT_CHANNEL = \"com.mycompnay.employee.payroll\";\r\n```\r\n\r\nAn employee object looks like this:\r\n\r\n```java\r\n\r\npublic static class Employee {\r\n       final String firstName;\r\n       final int employeeId;\r\n```\r\n\r\n\r\nThis example has three services: EmployeeHiringService, BenefitsService, and PayrollService.\r\n\r\nThese services are inproc services. QBit supports WebSocket, HTTP and REST remote services as well, but for now, let's focus on inproc services. If you understand inproc then you will understand remote.\r\n\r\nThe EmployeeHiringService actually fires off the events to other two services.\r\n\r\n```java\r\npublic class EmployeeHiringService {\r\n\r\n\r\n    public void hireEmployee(final Employee employee) {\r\n\r\n           int salary = 100;\r\n           System.out.printf(\"Hired employee %s\\n\", employee);\r\n\r\n           //Does stuff to hire employee\r\n\r\n           //Sends events\r\n           final EventManager eventManager =\r\n                               serviceContext().eventManager();\r\n           eventManager.send(NEW_HIRE_CHANNEL, employee);\r\n\r\n           eventManager.sendArray(PAYROLL_ADJUSTMENT_CHANNEL,\r\n                                     employee, salary);\r\n\r\n\r\n    }\r\n\r\n   }\r\n```\r\n\r\n\r\nNotice that we call sendArray so we can send the employee and their salary.\r\nThe listener for PAYROLL_ADJUSTMENT_CHANNEL will have to handle both an employee and an int\r\nthat represents the new employees salary.\r\nYou can also use event bus proxies so you do not have to call into the event bus at all.\r\n\r\nThe BenefitsService listens for new employees being hired so it can enroll them into the benefits system.\r\n\r\n```java\r\npublic static class BenefitsService {\r\n\r\n       @OnEvent(NEW_HIRE_CHANNEL)\r\n       public void enroll(final Employee employee) {\r\n\r\n           System.out.printf(\"Employee enrolled into benefits system employee %s %d\\n\",\r\n                   employee.getFirstName(), employee.getEmployeeId());\r\n\r\n       }\r\n\r\n```\r\n\r\nDaddy needs to get paid.\r\n\r\n```java\r\n    public static class PayrollService {\r\n\r\n        @OnEvent(PAYROLL_ADJUSTMENT_CHANNEL)\r\n        public void addEmployeeToPayroll(final Employee employee, int salary) {\r\n\r\n            System.out.printf(\"Employee added to payroll  %s %d %d\\n\",\r\n                    employee.getFirstName(), employee.getEmployeeId(), salary);\r\n\r\n        }\r\n\r\n    }\r\n\r\n```\r\n\r\nThe employee is the employee object from the EmployeeHiringService.\r\n\r\nso you can get your benefits, and paid!\r\n\r\nFind more details here:\r\n\r\n[QBit Event Bus more detailed example](https://github.com/advantageous/qbit/wiki/%5BRough-Cut%5D-Working-with-event-bus-for-QBit-the-microservice-engine)\r\n\r\n\r\n## Private event bus and event bus proxies\r\n\r\n You can define your own interface to the event bus and you can use your own event buses with QBit.\r\n Each module in your service can have its own internal event bus.\r\n\r\n To learn more read:\r\n [QBit Microservice working with a private event bus](https://github.com/advantageous/qbit/wiki/%5BRough-Cut%5D-Working-with-private-event-bus-for-inproc-microservices)\r\n and [QBit Java Microservice lib using your own interface to the event bus](https://github.com/advantageous/qbit/wiki/%5BRough-Cut%5D-Working-with-strongly-typed-event-bus-proxies-for-QBit-Java-Microservice-lib).\r\n\r\n\r\n\r\n## Queue Callbacks\r\n\r\n To really grasp QBit, one must grasp the concepts of a CallBack.\r\n\r\n A CallBack is a way to get an async response in QBit.\r\n\r\n You call a service method and it calls you back.\r\n\r\n Client proxies can have callbacks:\r\n\r\n\r\n#### Queue Callbacks - RecommendationService client interface\r\n```java\r\n\r\npublic interface RecommendationServiceClient {\r\n\r\n\r\n    void recommend(final Callback<List<Recommendation>> recommendationsCallback,\r\n                          final String userName);\r\n}\r\n\r\n```\r\n\r\nCallbacks are Java 8 Consumers with some optional extra error handling.\r\n\r\n\r\n#### Queue Callbacks - Callback\r\n\r\n```java\r\n\r\n\r\npublic interface Callback <T> extends java.util.function.Consumer<T> {\r\n    default void onError(java.lang.Throwable error) { /* compiled code */ }\r\n}\r\n\r\n```\r\n\r\nServices that can block should use callbacks.\r\nThus if loadUser blocked in the following example, it should really use a callback instead of returning a value.\r\n\r\npublic class RecommendationService {\r\n\r\n#### Queue Callbacks - Simple minded implementation of RecommendationService\r\n```java\r\n\r\n    private final SimpleLRUCache<String, User> users =\r\n            new SimpleLRUCache<>(10_000);\r\n\r\n    public List<Recommendation> recommend(final String userName) {\r\n        User user = users.get(userName);\r\n        if (user == null) {\r\n            user = loadUser(userName);\r\n        }\r\n        return runRulesEngineAgainstUser(user);\r\n    }\r\n\r\n```\r\n\r\n\r\nLet's pretend `loadUser` has to look in a local cache, and if the user is not found, look in an off-heap cache\r\nand if not found it must ask for the user from the UserService which must check its caches and perhaps fallback\r\nto loading the user data from a database or from other services.\r\nIn other words, `loadUser` can potentially block on IO.\r\n\r\n\r\n\r\n### Queue Callbacks - The first rule of Queue Club - don't block\r\n\r\n\r\nOur client does not block, but our service does. Going back to our `RecommendationService`.\r\nIf we get a lot of cache hits for user loads, perhaps the\r\nblock will not be that long, but it will be there and every time we have to fault in a user, the whole system\r\nis gummed up. What we want to be able to do is if we can't handle the recommendation request,\r\nwe go ahead and make an async call to the `UserDataService`. When that async callback comes back, then we\r\nhandle that request. In the mean time, we handle recommendation lists requests as quickly as we can.\r\nWe never block.\r\n\r\n\r\nSo let's revisit the service. The first thing we are going to do is make the service method take\r\na callback. Before we do that, let's set down some rules.\r\n\r\n\r\n#### The first rule of queue club don't block.\r\n#### The second rule of queue club if you are not ready, use a callback and continue handling stuff you are ready for\r\n\r\n\r\n#### Queue Callbacks - Adding a CallBack to the RecommendationService inproc microservice\r\n\r\n```java\r\npublic class RecommendationService {\r\n\r\n\r\n    public void recommend(final Callback<List<Recommendation>> recommendationsCallback,\r\n                          final String userName) {\r\n\r\n```\r\n\r\n\r\n\r\nNow we are taking a callback and we can decide when we want to handle this recommendation generation request.\r\nWe can do it right away if there user data we need is in-memory or we can delay it.\r\n\r\n\r\n#### If the user is found, call the callback right away for RecommendationService inproc microservice\r\n\r\n```java\r\n\r\n    public void recommend(final Callback<List<Recommendation>> recommendationsCallback,\r\n                          final String userName) {\r\n\r\n        /** Look for user in user cache. */\r\n        User user = users.get(userName);\r\n\r\n        /** If the user not found, load the user from the user service. */\r\n        if (user == null) {\r\n             ...\r\n        } else {\r\n             /* Call the callback now because we can handle the callback now. */\r\n            recommendationsCallback.accept(runRulesEngineAgainstUser(user));\r\n        }\r\n\r\n    }\r\n\r\n```\r\n\r\n\r\nNotice, if the user is found in the cache, we run our recommendation rules in-memory and call the callback right away\r\n`recommendationsCallback.accept(runRulesEngineAgainstUser(user))`.\r\n\r\nThe interesting part is what do we do if don't have the user loaded.\r\n\r\n\r\n#### If the user was not found, load him from the user microservice, but still don't block\r\n\r\n```java\r\n\r\n\r\n    public void recommend(final Callback<List<Recommendation>> recommendationsCallback,\r\n                          final String userName) {\r\n\r\n\r\n        /** Look for user in users cache. */\r\n        User user = users.get(userName);\r\n\r\n        /** If the user not found, load the user from the user service. */\r\n        if (user == null) {\r\n\r\n            /* Load user using Callback. */\r\n            userDataService.loadUser(new Callback<User>() {\r\n                @Override\r\n                public void accept(final User loadedUser) {\r\n                        handleLoadFromUserDataService(loadedUser,\r\n                                recommendationsCallback);\r\n                }\r\n            }, userName);\r\n\r\n        }\r\n        ...\r\n\r\n```\r\n\r\nHere we use a CallBack to load the user, and when the user is loaded, we call `handleLoadFromUserDataService`\r\nwhich adds some management about handling the callback so we can still handle this call, just not now.\r\n\r\n\r\n\r\n#### Lambda version of last example\r\n\r\n```java\r\n\r\n\r\n    public void recommend(final Callback<List<Recommendation>> recommendationsCallback,\r\n                          final String userName) {\r\n\r\n\r\n        /** Look for user in users cache. */\r\n        User user = users.get(userName);\r\n\r\n        /** If the user not found, load the user from the user service. */\r\n        if (user == null) {\r\n\r\n            /* Load user using lambda expression. */\r\n         userDataService.loadUser(\r\n                    loadedUser -> {\r\n                        handleLoadFromUserDataService(loadedUser,\r\n                        recommendationsCallback);\r\n                    }, userName);\r\n\r\n        }\r\n        ...\r\n\r\n```\r\n\r\nUsing lambdas like this makes the code more readable and terse, but remember don't deeply nest\r\nlambda expressions or you will create a code maintenance nightmare. Use them judiciously.\r\n\r\n\r\n### Queue Callbacks - Doing something later\r\n\r\nWhat we want is to handle the request for recommendations after the user service system loads\r\nthe user from its store.\r\n\r\n\r\n\r\n#### Handling UserServiceData callback methods once we get them.\r\n\r\n```java\r\n\r\npublic class RecommendationService {\r\n\r\n\r\n    private final SimpleLRUCache<String, User> users =\r\n            new SimpleLRUCache<>(10_000);\r\n\r\n    private UserDataServiceClient userDataService;\r\n\r\n\r\n    private BlockingQueue<Runnable> callbacks =\r\n               new ArrayBlockingQueue<Runnable>(10_000);\r\n\r\n\r\n    ...\r\n\r\n    public void recommend(final Callback<List<Recommendation>> recommendationsCallback,\r\n                          final String userName) {\r\n\r\n        ...\r\n\r\n    }\r\n\r\n    /** Handle defered recommendations based on user loads. */\r\n    private void handleLoadFromUserDataService(final User loadedUser,\r\n                                               final Callback<List<Recommendation>> recommendationsCallback) {\r\n\r\n        /** Add a runnable to the callbacks queue. */\r\n        callbacks.add(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n              List<Recommendation> recommendations = runRulesEngineAgainstUser(loadedUser);\r\n              recommendationsCallback.accept(recommendations);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n####  handleLoadFromUserDataService rewritten using Lambda\r\n\r\n```java\r\n\r\n\r\npublic class RecommendationService {\r\n\r\n...\r\n\r\n    /** Handle defered recommendations based on user loads. */\r\n    private void handleLoadFromUserDataService(final User loadedUser,\r\n                                               final Callback<List<Recommendation>> recommendationsCallback) {\r\n\r\n        /** Add a runnable to the callbacks list. */\r\n        callbacks.add(() -> {\r\n            List<Recommendation> recommendations = runRulesEngineAgainstUser(loadedUser);\r\n            recommendationsCallback.accept(recommendations);\r\n        });\r\n\r\n    }\r\n\r\n```\r\n\r\n\r\nThe important part there is that every time we get a callback call from `UserDataService`, we then\r\nperform our CPU intensive recommendation rules and callback our caller. Well not exactly, what we\r\ndo is enqueue an runnable onto our callbacks queue, and later we will iterate through those but when?\r\n\r\n\r\n### Queue Callbacks Handling callbacks when our receive queue is empty, a new batch started or we hit a batch limit\r\n\r\nThe `RecommendationService` can be notified when its queue is empty, it has started a new batch and when\r\nit has reached a batch limit. These are all good times to handle callbacks from the `UserDataService`.\r\n\r\n#### Draining our callback queue\r\n```java\r\n\r\n    @QueueCallback({\r\n            QueueCallbackType.EMPTY,\r\n            QueueCallbackType.START_BATCH,\r\n            QueueCallbackType.LIMIT})\r\n    private void handleCallbacks() {\r\n\r\n        flushServiceProxy(userDataService);\r\n        Runnable runnable = callbacks.poll();\r\n\r\n        while (runnable != null) {\r\n            runnable.run();\r\n            runnable = callbacks.poll();\r\n        }\r\n    }\r\n\r\n```\r\n\r\nIt is important to remember when handling callbacks from another microservice that you want to handle\r\ncallbacks from the other service before you handle more incomming requests from you clients.\r\nEssentially you have clients that have been waiting (async waiting but still), and these clients\r\nmight represent an open TCP/IP connection like an HTTP call so it is best to close them out\r\nbefore handling more requests and like we said they were already waiting around with an open connection\r\nfor users to load form the user service.\r\n\r\nTo learn more about CallBacks, plesae read [QBit Java MicroService Lib CallBack fundamentals]([Rough Cut] QBit Microservice Lib Working With CallBacks).\r\n\r\n\r\n\r\n\r\n## Workers - pools and shards\r\n\r\n```java\r\npublic class ServiceWorkers {\r\n\r\n    public static RoundRobinServiceDispatcher workers() {...\r\n\r\n    public static ShardedMethodDispatcher shardedWorkers(final ShardRule shardRule) {...\r\n```\r\n\r\nYou can compose sharded workers (for in-memory, thread safe, CPU intensive services), or workers for IO\r\nor talking to foreign services or foreign buses.\r\n\r\nHere is an example that uses a worker pool with three service workers in it:\r\n\r\nLet's say you have a service that does something:\r\n\r\n```java\r\n\r\n    //Your POJO\r\n    public  class MultiWorker {\r\n\r\n        void doSomeWork(...) {\r\n           ...\r\n        }\r\n\r\n    }\r\n\r\n```\r\n\r\nNow this does some sort of IO and you want to have a bank of these running not just one so you can do\r\nIO in parallel. After some performance testing, you found out that three is the magic number.\r\n\r\nYou want to use your API for accessing this service:\r\n\r\n```java\r\n    public  interface MultiWorkerClient {\r\n        void doSomeWork(...);\r\n    }\r\n\r\n```\r\n\r\nNow let's create a bank of these and use it.\r\n\r\nFirst create the QBit services which add the thread/queue/microbatch.\r\n\r\n```java\r\n\r\n        /* Create a service builder. */\r\n        final ServiceBuilder serviceBuilder = serviceBuilder();\r\n\r\n        /* Create some qbit services. */\r\n        final Service service1 = serviceBuilder.setServiceObject(new MultiWorker()).build();\r\n        final Service service2 = serviceBuilder.setServiceObject(new MultiWorker()).build();\r\n        final Service service3 = serviceBuilder.setServiceObject(new MultiWorker()).build();\r\n```\r\n\r\nNow add them to a ServiceWorkers object.\r\n\r\n```java\r\n\r\n        ServiceWorkers dispatcher;\r\n        dispatcher = workers(); //Create a round robin service dispatcher\r\n        dispatcher.addServices(service1, service2, service3);\r\n        dispatcher.start(); // start up the workers\r\n\r\n```\r\n\r\nYou can add services, POJOs and method consumers, method dispatchers to a service bundle.\r\nThe service bundle is an integration point into QBit.\r\n\r\nLet's add our new Service workers. ServiceWorkers is a ServiceMethodDispatcher.\r\n\r\n```Java\r\n        /* Add the dispatcher to a service bundle. */\r\n        bundle = serviceBundleBuilder().setAddress(\"/root\").build();\r\n        bundle.addServiceConsumer(\"/workers\", dispatcher);\r\n        bundle.start();\r\n```\r\n\r\nWe are probably going to add a helper method to the service bundle so most of this can happen in\r\na single call.\r\n\r\nNow you can start using your workers.\r\n\r\n```java\r\n\r\n        /* Start using the workers. */\r\n        final MultiWorkerClient worker = bundle.createLocalProxy(MultiWorkerClient.class, \"/workers\");\r\n\r\n```\r\n\r\nNow you could use Spring or Guice to configure the builders and the service bundle.\r\nBut you can just do it like the above which is good for testing and understanding QBit internals.\r\n\r\nQBit also supports the concept of sharded services which is good for sharding resources like CPU\r\n(run a rules engine on each CPU core for a user recommendation engine).\r\n\r\nQBit does not know how to shard your services, you have to give it a hint.\r\nYou do this through a shard rule.\r\n\r\n```java\r\npublic interface ShardRule {\r\n    int shard(String methodName, Object[] args, int numWorkers);\r\n}\r\n```\r\nWe worked on an app where the first argument to the services was the username, and then we used that to\r\nshard calls to a CPU intensive in-memory rules engine. This technique works. :)\r\n\r\nThe ServiceWorkers class has a method for creating a sharded worker pool.\r\n\r\n```java\r\n\r\n    public static ShardedMethodDispatcher shardedWorkers(final ShardRule shardRule) {\r\n        ...\r\n    }\r\n\r\n```\r\n\r\nTo use you just pass a shard key when you create the service workers.\r\n\r\n```java\r\n\r\n\r\n        dispatcher = shardedWorkers((methodName, methodArgs, numWorkers) -> {\r\n            String userName = methodArgs[0].toString();\r\n            int shardKey =  userName.hashCode() % numWorkers;\r\n            return shardKey;\r\n        });\r\n\r\n```\r\n\r\nThen add your services to the ServiceWorkers composition.\r\n```java\r\n        int workerCount = Runtime.getRuntime().availableProcessors();\r\n\r\n        for (int index = 0; index < workerCount; index++) {\r\n            final Service service = serviceBuilder\r\n                    .setServiceObject(new ContentRulesEngine()).build();\r\n            dispatcher.addServices(service);\r\n\r\n        }\r\n```\r\n\r\nThen add it to the service bundle as before.\r\n```java\r\n\r\n        dispatcher.start();\r\n\r\n        bundle = serviceBundleBuilder().setAddress(\"/root\").build();\r\n\r\n        bundle.addServiceConsumer(\"/workers\", dispatcher);\r\n        bundle.start();\r\n```\r\n\r\nThen just use it:\r\n\r\n```java\r\n        final MultiWorkerClient worker = bundle.createLocalProxy(MultiWorkerClient.class, \"/workers\");\r\n\r\n        for (int index = 0; index < 100; index++) {\r\n            String userName = \"rickhigh\" + index;\r\n            worker.pickSuggestions(userName);\r\n        }\r\n\r\n```\r\n\r\n### Built in shard rules\r\n\r\n```java\r\n\r\n\r\npublic class ServiceWorkers {\r\n...\r\n    public static ShardedMethodDispatcher shardOnFirstArgumentWorkers() {\r\n       ...\r\n    }\r\n\r\n...\r\n\r\n    public static ShardedMethodDispatcher shardOnFifthArgumentWorkers() {\r\n         ...\r\n    }\r\n\r\n\r\n    public static ShardedMethodDispatcher shardOnBeanPath(final String beanPath) {\r\n        ...\r\n    }\r\n\r\n```\r\n\r\nThe shardOnBeanPath allows you to create a complex bean path navigation call and use its property to shard on.\r\n\r\n```java\r\n\r\n     /* shard on 2nd arg which is an employee\r\n       Use the employees department's id property. */\r\n     dispatcher = shardOnBeanPath(\"[1].department.id\");\r\n\r\n     /* Same as above. */\r\n     dispatcher = shardOnBeanPath(\"1/department/id\");\r\n\r\n```\r\n\r\n[Read more about Service sharding and service workers here](https://github.com/advantageous/qbit/wiki/%5BRough-Cut%5D-QBit-Microservices-using-Service-Workers-and-sharded-service-workers)\r\n\r\n\r\nYou can find a lot more in the wiki. Also follow the commits.\r\nWe have been busy beavers.\r\n[QBit the microservice lib for Java - JSON, REST, WebSocket](https://github.com/advantageous/qbit/wiki).",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}